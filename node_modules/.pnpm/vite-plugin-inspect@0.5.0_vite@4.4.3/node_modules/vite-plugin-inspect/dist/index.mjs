import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import _debug from 'debug';
import { yellow } from 'kolorist';
import sirv from 'sirv';
import { createFilter } from '@rollup/pluginutils';

const DEFAULT_TIMEOUT = 6e4;
function createBirpc(functions, options) {
  const {
    post,
    on,
    eventNames = [],
    serialize = (i) => i,
    deserialize = (i) => i,
    timeout = DEFAULT_TIMEOUT
  } = options;
  const rpcPromiseMap = /* @__PURE__ */ new Map();
  const rpc = new Proxy({}, {
    get(_, method) {
      const sendEvent = (...args) => {
        post(serialize({ m: method, a: args, t: "q" }));
      };
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = (...args) => {
        return new Promise((resolve, reject) => {
          const id = nanoid();
          rpcPromiseMap.set(id, { resolve, reject });
          post(serialize({ m: method, a: args, i: id, t: "q" }));
          if (timeout >= 0) {
            setTimeout(() => {
              reject(new Error(`[birpc] timeout on calling "${method}"`));
              rpcPromiseMap.delete(id);
            }, timeout);
          }
        });
      };
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  on(async (data, ...extra) => {
    const msg = deserialize(data);
    if (msg.t === "q") {
      const { m: method, a: args } = msg;
      let result, error;
      try {
        result = await functions[method].apply(rpc, args);
      } catch (e) {
        error = e;
      }
      if (msg.i)
        post(serialize({ t: "s", i: msg.i, r: result, e: error }), ...extra);
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = rpcPromiseMap.get(ack);
      if (error)
        promise?.reject(error);
      else
        promise?.resolve(result);
      rpcPromiseMap.delete(ack);
    }
  });
  return rpc;
}
const cacheMap = /* @__PURE__ */ new WeakMap();
function cachedMap(items, fn) {
  return items.map((i) => {
    let r = cacheMap.get(i);
    if (!r) {
      r = fn(i);
      cacheMap.set(i, r);
    }
    return r;
  });
}
function createBirpcGroup(functions, channels, options = {}) {
  const getChannels = () => typeof channels === "function" ? channels() : channels;
  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));
  const boardcastProxy = new Proxy({}, {
    get(_, method) {
      const client = getClients();
      const functions2 = client.map((c) => c[method]);
      const sendCall = (...args) => {
        return Promise.all(functions2.map((i) => i(...args)));
      };
      sendCall.asEvent = (...args) => {
        functions2.map((i) => i.asEvent(...args));
      };
      return sendCall;
    }
  });
  function updateChannels(fn) {
    const channels2 = getChannels();
    fn?.(channels2);
    return getClients(channels2);
  }
  getClients();
  return {
    get clients() {
      return getClients();
    },
    updateChannels,
    boardcast: boardcastProxy
  };
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[Math.random() * 64 | 0];
  return id;
}

function createRPCServer(name, ws, functions) {
  const event = `${name}:rpc`;
  const group = createBirpcGroup(functions, () => cachedMap(Array.from(ws?.clients || []), (socket) => {
    return {
      on: (fn) => {
        ws.on(event, (data, source) => {
          if (socket === source)
            fn(data);
        });
      },
      post: (data) => {
        socket.send(event, data);
      }
    };
  }));
  ws.on("connection", () => {
    group.updateChannels();
  });
  return group.boardcast;
}

const debug = _debug("vite-plugin-inspect");
const _dirname = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
const dummyLoadPluginName = "__load__";
function PluginInspect(options = {}) {
  const {
    enabled = true
  } = options;
  if (!enabled) {
    return {
      name: "vite-plugin-inspect"
    };
  }
  const filter = createFilter(options.include, options.exclude);
  let config;
  const transformMap = {};
  const idMap = {};
  function hijackPlugin(plugin) {
    if (plugin.transform) {
      debug("hijack plugin transform", plugin.name);
      const _transform = plugin.transform;
      plugin.transform = async function(...args) {
        const code = args[0];
        const id = args[1];
        const start = Date.now();
        const _result = await _transform.apply(this, args);
        const end = Date.now();
        const result = typeof _result === "string" ? _result : _result?.code;
        if (filter(id) && result != null) {
          if (transformMap[id] && transformMap[id].slice(-1)[0]?.name === "vite:import-analysis")
            delete transformMap[id];
          if (!transformMap[id])
            transformMap[id] = [{ name: dummyLoadPluginName, result: code, start, end: start }];
          transformMap[id].push({ name: plugin.name, result, start, end });
        }
        return _result;
      };
    }
    if (plugin.load) {
      debug("hijack plugin load", plugin.name);
      const _load = plugin.load;
      plugin.load = async function(...args) {
        const id = args[0];
        const start = Date.now();
        const _result = await _load.apply(this, args);
        const end = Date.now();
        const result = typeof _result === "string" ? _result : _result?.code;
        if (filter(id) && result != null)
          transformMap[id] = [{ name: plugin.name, result, start, end }];
        return _result;
      };
    }
    if (plugin.resolveId) {
      debug("hijack plugin resolveId", plugin.name);
      const _resolveId = plugin.resolveId;
      plugin.resolveId = async function(...args) {
        const id = args[0];
        const _result = await _resolveId.apply(this, args);
        const result = typeof _result === "object" ? _result?.id : _result;
        if (!id.startsWith("./") && result && result !== id)
          idMap[id] = result;
        return _result;
      };
    }
  }
  function resolveId(id = "") {
    if (id.startsWith("./"))
      id = resolve(config.root, id).replace(/\\/g, "/");
    return resolveIdRec(id);
  }
  function resolveIdRec(id) {
    return idMap[id] ? resolveIdRec(idMap[id]) : id;
  }
  function getIdInfo(id) {
    const resolvedId = resolveId(id);
    return {
      resolvedId,
      transforms: transformMap[resolvedId] || []
    };
  }
  function configureServer(server) {
    const _invalidateModule = server.moduleGraph.invalidateModule;
    server.moduleGraph.invalidateModule = function(...args) {
      const mod = args[0];
      if (mod?.id)
        delete transformMap[mod.id];
      return _invalidateModule.apply(this, args);
    };
    server.middlewares.use("/__inspect", sirv(resolve(_dirname, "../dist/client"), {
      single: true,
      dev: true
    }));
    createRPCServer("vite-plugin-inspect", server.ws, {
      list,
      getIdInfo,
      getPluginMetics,
      resolveId,
      clear
    });
    function list() {
      const modules = Object.keys(transformMap).sort().map((id) => {
        const plugins = transformMap[id]?.map((i) => i.name);
        const deps = Array.from(server.moduleGraph.getModuleById(id)?.importedModules || []).map((i) => i.id || "").filter(Boolean);
        return {
          id,
          plugins,
          deps,
          virtual: plugins[0] !== "__load__"
        };
      });
      return {
        root: config.root,
        modules
      };
    }
    function getPluginMetics() {
      const map = {};
      config.plugins.forEach((i) => {
        map[i.name] = {
          name: i.name,
          enforce: i.enforce,
          invokeCount: 0,
          totalTime: 0
        };
      });
      Object.values(transformMap).forEach((transformInfos) => {
        transformInfos.forEach(({ name, start, end }) => {
          if (name === dummyLoadPluginName)
            return;
          if (!map[name])
            map[name] = { name, totalTime: 0, invokeCount: 0 };
          map[name].totalTime += end - start;
          map[name].invokeCount += 1;
        });
      });
      const metrics = Object.values(map).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name)).sort((a, b) => b.invokeCount - a.invokeCount).sort((a, b) => b.totalTime - a.totalTime);
      return metrics;
    }
    function clear(_id) {
      const id = resolveId(_id);
      if (id) {
        const mod = server.moduleGraph.getModuleById(id);
        if (mod)
          server.moduleGraph.invalidateModule(mod);
        delete transformMap[id];
      }
    }
    server.httpServer?.once("listening", () => {
      const protocol = config.server.https ? "https" : "http";
      const port = config.server.port;
      setTimeout(() => {
        console.log(`  > Inspect: ${yellow(`${protocol}://localhost:${port}/__inspect/`)}
`);
      }, 0);
    });
  }
  return {
    name: "vite-plugin-inspect",
    apply: "serve",
    configResolved(_config) {
      config = _config;
      config.plugins.forEach(hijackPlugin);
    },
    configureServer
  };
}

export { PluginInspect as default };
